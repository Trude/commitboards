#!/usr/bin/env ruby

require 'fileutils'

class Capturer
  def initialize
    @project_dir          = `git rev-parse --show-toplevel 2>&1`.strip
    @project_name         = ENV['project_name'] || @project_dir.split(File::SEPARATOR).last

    @home_dir             = File.expand_path('~')
    @cb_dir               = File.join(@home_dir, '.commitboards')
    @cb_bin_dir           = File.join(@cb_dir, 'bin')
    @imagesnap_executable = File.join(@cb_bin_dir, 'imagesnap')
    @cb_executable        = File.join(@cb_bin_dir, 'capture')
    @cb_projects_dir      = File.join(@cb_dir, 'projects')
    @cb_project_dir       = ensure_dir_present(File.join(@cb_projects_dir, @project_name))
    @commits_url          = ARGV.first || exit('No commit url given')
  end

  def capture
    commit_sha = get_last_commit_sha
    capture_tmp_image(commit_sha)
    upload_success = upload(commit_sha)
    if upload_success
      upload_previous_captures
    end
  end

private

  def get_last_commit_sha
    `git rev-parse HEAD`.strip
  end

  def capture_tmp_image(commit_sha)
    inside_dir @cb_project_dir do
      `#{@imagesnap_executable} -q -w 1 #{snapshot_filename(commit_sha)}`
    end
  end

  def upload(commit_sha)
    message = get_commit_message_for(commit_sha)
    name, email = get_name_and_email
    commit_timestamp = get_commit_timestamp_for(commit_sha)
    upload_success = post_request(
      :commit_sha => commit_sha,
      :project_name => @project_name,
      :name => name,
      :message => message,
      :email => email,
      :timestamp => commit_timestamp,
    )

    clean_uploaded_file(commit_sha) if upload_success

    upload_success
  end

  def get_commit_timestamp_for(commit_sha)
    timestamp_str = `git show -s --format=%ct #{commit_sha}`.strip
  end

  def get_commit_message_for(commit_sha)
    message = `git log --format=%B -n 1 #{commit_sha}`.strip
  end

  def get_name_and_email
    name  = `git config --get user.name`.strip
    email = `git config --get user.email`.strip
    [name, email]
  end

  def post_request(opts)
    inside_dir @cb_project_dir do
      message  = shellescape opts.fetch(:message)
      email    = shellescape opts.fetch(:email)
      name     = shellescape opts.fetch(:name)
      project_name = shellescape opts.fetch(:project_name)
      commit_sha = opts.fetch(:commit_sha)
      timestamp = opts.fetch(:timestamp)
      filename = shellescape snapshot_filename(commit_sha)

      upload_response = `curl -s -F commit[project]=#{project_name} -F commit[timestamp]=#{timestamp} -F commit[email]=#{email} -F commit[name]=#{name} -F commit[message]=#{message} -F commit[image]=@#{filename} #{@commits_url}`

      if upload_response == 'ok'
        puts "Uploaded #{commit_sha} to #{@commits_url}"
        return true
      else
        puts FileUtils.pwd
        puts "Could not upload #{commit_sha} to #{@commits_url} (got code: #{$?} and response: '#{upload_response}')"
        return false
      end
    end
  end

  def upload_previous_captures
    Dir[File.join(@cb_project_dir, '*.jpg')].sort do |f1, f2|
      File.ctime(f1) <=> File.ctime(f2) # sort by date
    end.each do |filename|
      commit_sha = commit_sha_from_filename(filename)
      upload(commit_sha)
    end
  end

  def snapshot_filename(commit_sha)
    "#{commit_sha}.jpg"
  end

  def commit_sha_from_filename(filename)
    filename.match(/([0-9a-f]{40})\.jpg/).captures.first
  end

  def clean_uploaded_file(commit_sha)
    inside_dir @cb_project_dir do
      FileUtils.rm snapshot_filename(commit_sha)
    end
  end

  def ensure_dir_present(path)
    FileUtils.mkdir_p(path) unless File.directory?(path)
    path
  end

  def inside_dir(dirname)
    start_dir = FileUtils.pwd
    FileUtils.cd(dirname)

    yield

    FileUtils.cd(start_dir)
  end

  # from http://svn.ruby-lang.org/repos/ruby/trunk/lib/shellwords.rb
  def shellescape(str)
    # An empty argument will be skipped, so return empty quotes.
    return "''" if str.empty?

    str = str.dup

    # Process as a single byte sequence because not all shell
    # implementations are multibyte aware.
    str.gsub!(/([^A-Za-z0-9_\-.,:\/@\n])/n, "\\\\\\1")

    # A LF cannot be escaped with a backslash because a backslash + LF
    # combo is regarded as line continuation and simply ignored.
    str.gsub!(/\n/, "'\n'")

    return str
  end
end

Capturer.new.capture
